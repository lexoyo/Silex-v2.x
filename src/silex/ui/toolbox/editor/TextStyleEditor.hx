package silex.ui.toolbox.editor;

import silex.property.PropertyModel;
import silex.component.ComponentModel;
import silex.layer.LayerModel;

import js.Lib;
import js.Dom;

import org.slplayer.component.ui.DisplayObject;
import org.slplayer.util.DomTools;

/**
 * Editor for text styles. 
 * Editors are SLPlayer components, in charge of handling HTML input elements, 
 * in order to let the user enter values and edit css style values or tag attributes.
 */
@tagNameFilter("fieldset div")
class TextStyleEditor extends EditorBase 
{
	/**
	 * Information for debugging, e.g. the class name
	 */ 
	public static inline var DEBUG_INFO:String = "silex.ui.toolbox.editor.TextStyleEditor class";
	/**
	 * selected element
	 */ 
	public var selectedItem(default, setSelectedItem):HtmlDom;
	/**
	 * prevent the refresh action generated by our modifications on the model
	 */
	private var propertyChangePending:Bool = false;

	/**
	 * Constructor
	 * Start listening the input events
	 */
	public function new(rootElement:HtmlDom, SLPId:String)
	{trace("TextStyleEditor "+rootElement);
		super(rootElement, SLPId);
		// listen to the input event
		rootElement.addEventListener("input", onInput, true);
		rootElement.addEventListener("change", onInput, true);
		// listen to the property change event
		PropertyModel.getInstance().addEventListener(PropertyModel.ON_PROPERTY_CHANGE, onPropertyChange, DEBUG_INFO);
		// listen to the component change event
		ComponentModel.getInstance().addEventListener(ComponentModel.ON_SELECTION_CHANGE, onSelectComponent, DEBUG_INFO);
		// listen to the layer change event
		LayerModel.getInstance().addEventListener(LayerModel.ON_SELECTION_CHANGE, onSelectLayer, DEBUG_INFO);
	}
	/**
	 * Setter for the selected item
	 * Dispatch the change event with the item reference as the detail property of the custom event
	 */
	public function setSelectedItem(item:HtmlDom):HtmlDom {
		selectedItem = item;
		refresh();
		return selectedItem;
	}
	/**
	 * callback for the click event, validate the data
	 */
	private function onInput(e:Event) {
		trace("TextStyleEditor onInput");
		e.preventDefault();
		save();
	}
	/**
	 * Callback for the component model event
	 * display the component style
	 */
	private function onSelectComponent(e:CustomEvent) {
		trace("TextStyleEditor onSelectComponent");
		selectedItem = e.detail;
	}
	/**
	 * Callback for the layer model event
	 * display the layer style
	 */
	private function onSelectLayer(e:CustomEvent) {
		trace("TextStyleEditor onSelectLayer");
		if (e.detail == null){
			selectedItem = null;
		}
		else{
			selectedItem = e.detail.rootElement;
		}
	}
	/**
	 * Callback for the PropertyModel singleton
	 * A property value has changed,
	 * display the new value if it corresponds to the property watched by this editor
	 * @param 	e 	CustomEvent with the PropertyData object in e.detail
	 */
	private function onPropertyChange(e:CustomEvent) {
		if (propertyChangePending)
			return;

/*		if (e.detail.name == ATTRIBUTE_NAME){
			var textArea = DomTools.getSingleElement(rootElement, TEXT_INPUT_CLASS_NAME, true);
			load(e.detail.value);
		}
*/
		refresh();
	}
	/**
	 * refresh display
	 */
	private function refresh() {
		if (selectedItem != null)
			load(selectedItem);
		else
			reset();
	}
	/**
	 * set the value of the input control with name in its class name
	 */
/*	private function setOptionValue(name:String, value:String){
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName;
		
		return cast(element).value = value;
	}
/**/
	private function hasOptionValue(name:String, value:String):Bool{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		for (idx in 0...options.length){
			if(cast(options[idx]).value == value)
				return true;
		}
		return false;
	}
	private function getOptions(name:String):HtmlCollection<Option>{
		var element = DomTools.getSingleElement(rootElement, name, true);
		var options = element.getElementsByTagName("option");
		return cast(options);
	}
	/**
	 * set the value of the input control with name in its class name
	 */
	private function setInputValue(name:String, value:String){
		trace("setInputValue "+name+", "+value);
		var element = DomTools.getSingleElement(rootElement, name, true);
		return cast(element).value = value;
	}
	/**
	 * get the value from the input control with name in its class name
	 */
	private function getInputValue(name:String):String{
		var element = DomTools.getSingleElement(rootElement, name, true);
		return cast(element).value;
	}
	/**
	 * reset the values
	 */
	private function reset() {
		trace("reset ");
		// font family
		setInputValue("text_font", "");
		// font size
		setInputValue("text_size", "");
		setInputValue("text_size_unit", "");
		setInputValue("text_size_num", "");
		// font weight
		setInputValue("text_weight", "");
		// font style
		setInputValue("text_style", "");
		// font variant
		setInputValue("text_variant", "");
		// font variant
		setInputValue("text_lineheight", "");
		// font variant
		setInputValue("text_lineheight_unit", "");
		// case
		setInputValue("text_case", "");
		// color
		setInputValue("text_color", "");
		// decoration
		setInputValue("text_decoration", "");
	}
	/**
	 * display the property value
	 */
	private function load(element:HtmlDom) {
		trace("load "+element);

		// font family
		var value = element.style.fontFamily;
		setInputValue("text_font", value);

		// font size + unit
		var value = element.style.fontSize;
		if (hasOptionValue("text_size", value)){
			// case of a label or "", then no unit
			setInputValue("text_size", value);
			setInputValue("text_size_unit", "");
			setInputValue("text_size_num", "");
		}else{
			// case of a number + unit
			var options = getOptions("text_size_unit");
			for (idx in 0...options.length){
				// if the value ends with one of the units
				if (StringTools.endsWith(value, cast(options[idx]).value)){
					// case of a number + unit
					setInputValue("text_size", "");
					setInputValue("text_size_num", Std.string(Std.parseInt(value)));
					setInputValue("text_size_unit", cast(options[idx]).value);
				}
			}
		}
		// font weight
		var value = element.style.fontWeight;
		setInputValue("text_weight", value);
		// font style
		var value = element.style.fontStyle;
		setInputValue("text_style", value);
		// font variant
		var value = element.style.fontVariant;
		setInputValue("text_variant", value);
		// line height: a number + unit
		var value = element.style.lineHeight;
		var options = getOptions("text_lineheight_unit");
		for (idx in 0...options.length){
			// if the value ends with one of the units
			if (StringTools.endsWith(value, cast(options[idx]).value)){
				// case of a number + unit
				var valInt = Std.parseInt(value);
				var valStr = "";
				if (valInt != null) 
					valStr = Std.string(valInt);
				setInputValue("text_lineheight", valStr);
				setInputValue("text_lineheight_unit", cast(options[idx]).value);
			}
		}
		// case
		var value = element.style.textTransform;
		setInputValue("text_case", value);
		// color
		var value = element.style.color;
		setInputValue("text_color", value);
		// color
		var value = element.style.textDecoration;
		setInputValue("text_decoration", value);
	}
	/**
	 * apply the property value
	 */
	private function save() {
		trace("TextStyleEditor save");
		var propertyModel = PropertyModel.getInstance();

		// lock redraw
		propertyChangePending = true;

		// font family
		var value = getInputValue("text_font");
		propertyModel.setStyle(selectedItem, "fontFamily", value);
		// font size
		var value = getInputValue("text_size");
		if (value != ""){
			// case of a label
			propertyModel.setStyle(selectedItem, "fontSize", value);
		}else{
			// number + unit
			var value = getInputValue("text_size_num");
			var unit = getInputValue("text_size_unit");
			propertyModel.setStyle(selectedItem, "fontSize", value+unit);
		}
		// font weight
		var value = getInputValue("text_weight");
		propertyModel.setStyle(selectedItem, "fontWeight", value);
		// font style
		var value = getInputValue("text_style");
		propertyModel.setStyle(selectedItem, "fontStyle", value);
		// font variant
		var value = getInputValue("text_variant");
		propertyModel.setStyle(selectedItem, "fontVariant", value);
		// line height
		var value = getInputValue("text_lineheight");
		var unit = getInputValue("text_lineheight_unit");
		propertyModel.setStyle(selectedItem, "lineHeight", value+unit);
		// case
		var value = getInputValue("text_case");
		propertyModel.setStyle(selectedItem, "textTransform", value);
		// color
		var value = getInputValue("text_color");
		propertyModel.setStyle(selectedItem, "color", value);
		// decoration
		var value = getInputValue("text_decoration");
		propertyModel.setStyle(selectedItem, "textDecoration", value);

		// unlock redraw
		propertyChangePending = false;
	}
}